# 性能考虑

---

#### 设置 KEY 过期时间

如果应用将 Redis 定位为缓存 Cache 使用，对于存放的 KEY 一定要设置超时时间！Redis KEY 默认不做过期处理，这些Key会一直占用内存不释放，造成极大的浪费，而且随着时间的推移会导致内存占用越来越大，直到达到服务器内存上限！另外 KEY 的超时长短要根据业务综合评估，而不是越长越好！

> * 超时时间尽可能设置得短些
> * 每次对KEY进行写入操作时，设置超时时间，让超时时间顺延

#### 优先存储热数据

Redis 属于内存存储数据库，所有数据都存储在内存中，而内存比较有限，成本也比较高，所以对于热数据，也就是是经常访问的数据，优先存储 Redis。

冷数据如非必要，无需存储到 Redis。

#### 停用 KEYS \* 命令

当我们关注一个 redis 实例的统计数据，我们会快速地输入”KEYS \*” 命令，这样 key 的信息会很明显地展示出来。

当你有1300万个key时，执行速度将会变慢。因为KEYS命令的时间复杂度是O\(n\)，其中n是要返回的keys的个数，这样这个命令的复杂度就取决于数据库的大小了。

并且在这个操作执行期间，其它任何命令在你的实例中都无法执行。

作为一个替代命令，看一下 SCAN 吧，其允许你以一种更友好的方式来执行

SCAN 通过增量迭代的方式来扫描数据库。这一操作基于游标的迭代器来完成的，因此只要你觉得合适，你可以随时停止或继续。

```

KEYS *

```

#### 谨慎全量操作 Hashes、Set

> 尽可能使用其他命令代替【** 时间复杂度O\(N\) **】的命令。
>
> 在使用HASH结构存储对象属性时，开始只有有限的十几个field，往往使用HGETALL获取所有成员，效率也很高。
>
> 但是随着业务发展，会将field扩张到上百个甚至几百个，此时还使用HGETALL会出现效率急剧下降、网卡频繁打满等问题。
>
> 此时建议根据业务拆分为多个Hash结构；或者如果大部分都是获取所有属性的操作,可以将所有属性序列化为一个STRING类型存储！
>
> 同样在使用SMEMBERS操作SET结构类型时也是相同的情况！

#### 尽可能使用 Hashes

> 尽可能使用 Hashes 吧。 Hashes 将会带给你一种前所未有的体验。尽可能的少使用下面的 KEY 结构，减少 KEY 数量。
>
> ```Redis
> user:1000:username user1
> user:1000:email user1@qq.com
> user:1000:mobile 13888888888
> ```
>
> 使用 Hashes 代替吧，你会发现，一个 KEY 就够了。
>
> ```
> HSET user_info:1000 username user1
> HMSET user_info:1000 email user1@qq.com mobile 13888888888
> ```



